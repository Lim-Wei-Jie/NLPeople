import base64
import datetime
import io

import pandas as pd
import plotly.express as px  # (version 4.7.0 or higher)
import plotly.graph_objects as go
import dash
from dash import Dash, dash_table, dcc, html, Input, Output, State, exceptions, MATCH, ALL, no_update, ctx  # pip install dash (version 2.0.0 or higher)

import dash_bootstrap_components as dbc

import math
import re

import openai
openai.api_key = "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"

dash.register_page(__name__)


layout = html.Div([html.H4('Upload Multiple Saved Excel files to view in Dashboard'),
            html.P("For the dashboard to work, the excel files should be generated by the 'export' button of the 'Extracted Table' in the PDF page or Image page"),
            dcc.Upload(
                id='upload-data',
                children=html.Div([
                    'Drag and Drop or ',
                    html.A('Select CSV or Excel Files')
                ]),
                style={
                    'width': '90%',
                    'height': '60px',
                    'lineHeight': '60px',
                    'borderWidth': '1px',
                    'borderStyle': 'dashed',
                    'borderRadius': '5px',
                    'textAlign': 'center',
                    'margin': '10px'
                },
                # Allow multiple files to be uploaded
                multiple=True
            ),
            html.Br(),

            html.Div(id='output-data-upload', children=[]),
            ])

# Upload CSV and Excel sheets to the app and create the tables----------------------------------------------------------
@dash.callback(Output('output-data-upload', 'children'),
                Input('upload-data', 'contents'),
                State('upload-data', 'filename'),
                State('upload-data', 'last_modified'),
                State('output-data-upload', 'children'),
                prevent_initial_call=True
)
def update_output(contents, filename, date, children):
    # part of the code snippet is from https://dash.plotly.com/dash-core-components/upload
    if contents is not None:
        for i, (c, n, d) in enumerate(zip(contents, filename, date)):

            content_type, content_string = contents[i].split(',')

            decoded = base64.b64decode(content_string)
            try:
                if 'csv' in filename[i]:
                    # Assume that the user uploaded a CSV file
                    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
                elif 'xls' in filename[i]:
                    # Assume that the user uploaded an excel file
                    df = pd.read_excel(io.BytesIO(decoded))

                # Some cleaning
                # print("BEFORE TRANSPOSE", df)
                df = df.T
                # print("AFTER TRANSPOSE", df)
                new_header = df.iloc[0]
                df = df[1:]
                # print("REMOVE HEADERS", df)
                df.columns = new_header
                # print("WITH NEW HEADER", df)
                print("df.columns", list(df.columns.values))
                # print("df revenue", list(df['Revenue']))

                # df.fillna("0")

                # if cash flow statement, user needs to add in additional metrics from elsewhere to calculate ratios
                it_is_a = ''
                all_metrics = " ".join(list(df.columns.values))
                if 'assets' in all_metrics.lower() and 'liabilities' in all_metrics.lower() and 'equity' in all_metrics.lower():
                    it_is_a = 'balance sheet'
                elif 'cash flow' in all_metrics.lower():
                    it_is_a = 'cash flow statement'
                    if "current liabilities" not in all_metrics.lower():
                        df['current liabilities'] = ""
                    if "total liabilities" not in all_metrics.lower():
                        df['total liabilities'] = ""
                else:
                    it_is_a = 'income statement'

                # Create the tables and empty graphs
                children.append(
                    html.Div([
                        dbc.Row([
                            dbc.Col(
                                dbc.Card([
                                    dbc.CardBody([
                                        html.H4(filename[i]),
                                        dash_table.DataTable(
                                            df.to_dict('records'),
                                            [{'name': i, 'id': i, 'selectable':True} for i in df.columns],
                                            page_size=5,
                                            filter_action='native',
                                            column_selectable='single',
                                            selected_columns=[df.columns[1]], # preselect the 2nd columns
                                            style_table={'overflowX': 'auto'},
                                            id={'type': 'dynamic-table',
                                                'index': i},
                                            editable=True
                                        ),

                                        html.Br(), html.Br(),
                                        html.H4("Thresholds", id={"type": "threshold-heading-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("Threshold values must be numbers!", target={"type": "threshold-heading-tooltip", "index": i}, placement="top"),
                                        html.Br(), 
                                        html.Div(id={
                                                'type': 'app-calculated-ratios',
                                                'index': i
                                            }, style={'display': 'inline-block'}),
                                        html.Br(), html.Br(),
                                        dash_table.DataTable(
                                            page_size=5,
                                            style_table={'overflowX': 'auto'},
                                            id={'type': 'threshold-boxes',
                                                'index': i},
                                            editable=True,
                                        ),

                                        html.Br(), html.Br(),
                                        html.H4("Add Calculations", id={"type": "add-calculations-heading-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("Column 1 and Column 2 accepts EXACT column names or already defined ratio names. Operator accepts +, -, *, /. Ratio Name is text of your choice.", target={"type": "add-calculations-heading-tooltip", "index": i}, placement="top"),
                                        html.Br(),
                                        dash_table.DataTable(
                                            page_size=5,
                                            style_table={'overflowX': 'auto'},
                                            id={'type': 'user-add-ratios',
                                                'index': i},
                                            editable=True,
                                            row_selectable='multi',
                                            row_deletable=True
                                        ),
                                        html.Button('Add Row', 
                                                    id={'type': 'add-rows-for-ratios',
                                                        'index': i},
                                                    n_clicks=0),
                                        html.Br(), html.Br(),
                                        html.Div(id={
                                            'type': 'add-calculations-warning-note',
                                            'index': i
                                        }),

                                        html.Br(), html.Br(),
                                        html.H4("Financial Ratios"),
                                        html.Div(id={
                                            'type': 'dynamic-text',
                                            'index': i
                                        }, style={'display': 'inline-block'}),
                                        html.P(id={
                                                    'type': 'dynamic-container',
                                                    'index': i
                                            }),

                                        html.Br(), html.Br(),
                                        html.H4("GPT Analysis", id={"type": "gpt-analysis-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("GPT Analysis is based on the ratios in the 'Thresholds' table", target={"type": "gpt-analysis-tooltip", "index": i}, placement="top"),
                                        html.Br(),
                                        html.Button('GPT Analysis', 
                                                    id={'type': 'gpt-button',
                                                        'index': i},
                                                    n_clicks=0),
                                        html.Br(), html.Br(),
                                        html.P(id={
                                                    'type': 'gpt-output',
                                                    'index': i
                                            })
                                    ])
                                ], style={"height":"100%"}), width=6
                            ),
                            dbc.Col(
                                dbc.Card([
                                    dbc.CardBody([
                                        html.P('Type of Graph:'),
                                        dcc.Dropdown(id={'type':'type_of_graph', 'index':i},
                                                    options=['bar', 'line'],
                                                    multi=False,
                                                    value='line',
                                                    style={'width': '40%'}),
                                        
                                        dcc.Graph(
                                            id={
                                                'type': 'dynamic-graph',
                                                'index': i
                                            },
                                            figure={}
                                        ),
                                    ])
                                ], style={"height":"100%"}), width=6
                            )
                        ]),
                        html.Hr()
                    ])
                )

            except Exception as e:
                print(e)
                return html.Div([
                    'There was an error processing this file.'
                ])
        return children
    else:
        return ""


# Build the graphs from the filtered data in the Datatable--------------------------------------------------------------
@dash.callback(Output({'type': 'dynamic-graph', 'index': MATCH}, 'figure'),
                Input({'type': 'dynamic-table', 'index': MATCH}, 'derived_virtual_indices'),
                Input({'type': 'dynamic-table', 'index': MATCH}, 'selected_columns'),
                Input({'type': 'dynamic-table', 'index': MATCH}, 'data'),
                Input({'type': 'type_of_graph', 'index': MATCH}, 'value')
)
def create_graphs(filtered_data, selected_col, all_data, type_of_graph):
    if filtered_data is not None:
        dff = pd.DataFrame(all_data)
        dff = dff[dff.index.isin(filtered_data)].fillna(0)
        print("dff", dff)

        if selected_col[0] == dff.columns[0]:
            return no_update
        else:
            if type_of_graph == 'line':
                fig = px.line(dff,
                            x = dff.columns[0],
                            y = selected_col[0])
            elif type_of_graph == 'bar':
                fig = px.bar(dff,
                            x = dff.columns[0],
                            y = selected_col[0])
            else:
                raise exceptions.PreventUpdate
            return fig

@dash.callback([Output({'type': 'dynamic-container', 'index': MATCH}, 'children'),
                Output({'type': 'dynamic-text', 'index': MATCH}, 'children'),
                Output({'type': 'threshold-boxes', 'index': MATCH}, 'data'),
                Output({'type': 'threshold-boxes', 'index': MATCH}, 'columns'),
                Output({'type': 'app-calculated-ratios', 'index': MATCH}, 'children'),
                Output({'type': 'user-add-ratios', 'index': MATCH}, 'data'),
                Output({'type': 'user-add-ratios', 'index': MATCH}, 'columns'),
                Output({'type': 'add-calculations-warning-note', 'index': MATCH}, 'children'),
                Output({'type': 'gpt-output', 'index': MATCH}, 'children')],
                Input({'type': 'dynamic-table', 'index': MATCH}, 'data'),
                Input({'type': 'threshold-boxes', 'index': MATCH}, 'data'),
                Input({'type': 'threshold-boxes', 'index': MATCH}, 'columns'),
                State({'type': 'user-add-ratios', 'index': MATCH}, 'data'),
                Input({'type': 'user-add-ratios', 'index': MATCH}, 'columns'),
                Input({'type': 'user-add-ratios', 'index': MATCH}, 'selected_rows'),
                Input({'type': 'add-rows-for-ratios', 'index': MATCH}, 'n_clicks'),
                Input({'type': 'gpt-button', 'index': MATCH}, 'n_clicks'))
def display_metrics(all_data, threshold_data, threshold_columns, user_add_ratios_datatable, user_add_ratios_columns, selected_rows, add_rows_n_clicks, gpt_n_clicks):
    print("ALL DATA", all_data)
    # Income statement, cash flow or balance sheet?
    df = pd.DataFrame(all_data)
    df = df.fillna(0)
    it_is_a = ''
    all_metrics = " ".join(list(df.columns.values))
    text = []
    if 'assets' in all_metrics.lower() and 'liabilities' in all_metrics.lower() and 'equity' in all_metrics.lower():
        it_is_a = 'balance sheet'
    elif 'cash flow' in all_metrics.lower():
        it_is_a = 'cash flow statement'
    else:
        it_is_a = 'income statement'
    
    print("it is a", it_is_a)

    # this is for user to know the metrics needed to calculate the financial ratios 
    # required metrics will be shown in tooltip
    required_metrics_for_ratio = {}

    # key_metrics is financial ratios 
    key_metrics = {}
    if it_is_a == 'income statement':
        gross_profit = {}
        gross_margin = {}
        operating_income = {}
        operating_margin = {}

        revenue = {}
        cost_of_goods_sold = {}
        operating_expenses = {}

        for h in list(df.columns.values)[1:]: # list of column names except first column
            if 'revenue' in h.lower(): # if column is about revenue
                for i in range(len(df[h].tolist())): # for each year store the value in a dictionary
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        revenue[df[df.columns[0]][i]] = 0
                    else:
                        revenue[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'cost of goods sold' in h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        cost_of_goods_sold[df[df.columns[0]][i]] = 0
                    else:
                        cost_of_goods_sold[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'operating expenses' in h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        operating_expenses[df[df.columns[0]][i]] = 0
                    else:
                        operating_expenses[df[df.columns[0]][i]] = df[h].tolist()[i]
        
        print("revenue:", revenue)
        print("cost_of_goods_sold", cost_of_goods_sold)

        for y in df.iloc[:, 0].tolist():
            if y in revenue and y in cost_of_goods_sold:
                gross_profit[y] = float(revenue[y]) - float(cost_of_goods_sold[y])
            if y in gross_profit and y in revenue:
                if revenue[y] == 0:
                    gross_margin[y] = 0
                else:
                    gross_margin[y] = str(round(float(gross_profit[y]) / float(revenue[y]) * 100, 2)) + "%"
            if y in gross_profit and y in operating_expenses:
                operating_income[y] = float(gross_profit[y]) - float(operating_expenses[y])
            if y in operating_income and y in revenue:
                if revenue[y] == 0:
                    gross_margin[y] = 0
                else:
                    operating_margin[y] = str(round(float(operating_income[y]) / float(revenue[y])*100, 2)) + "%"

        # key_metrics['Gross Profit'] = gross_profit
        key_metrics['Gross Margin'] = gross_margin
        key_metrics['Operating Margin'] = operating_margin

        required_metrics_for_ratio['Gross Margin'] = ["Revenue", "Cost of Goods Sold"]
        required_metrics_for_ratio['Operating Margin'] = ["Revenue", "Cost of Goods Sold", "Operating Expenses"]

        

    elif it_is_a == 'balance sheet':
        current_ratio = {}
        quick_ratio = {}
        current_assets = {}
        current_liabilities = {}
        inventories = {}
        for h in list(df.columns.values)[1:]:
            if 'current assets' == h.lower() or 'total current assets' == h.lower():
                for i in range(len(df[h].tolist())): 
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        current_assets[df[df.columns[0]][i]] = 0
                    else:
                        current_assets[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'current liabilities' in h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        current_liabilities[df[df.columns[0]][i]] = 0
                    else:
                        current_liabilities[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'inventories' in h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        inventories[df[df.columns[0]][i]] = 0
                    else:
                        inventories[df[df.columns[0]][i]] = df[h].tolist()[i]
        
        for y in df.iloc[:, 0].tolist():
            if y in current_assets and y in current_liabilities:
                if current_liabilities[y] == 0:
                    current_ratio[y] = 0
                else:
                    current_ratio[y] = round(float(current_assets[y]) / float(current_liabilities[y]), 2)
            if y in current_assets and y in current_liabilities and y in inventories:
                if current_liabilities[y] == 0:
                    quick_ratio[y] = 0
                else:
                    quick_ratio[y] = round((float(current_assets[y]) - float(inventories[y])) / float(current_liabilities[y]), 2)

        key_metrics['Current Ratio'] = current_ratio
        key_metrics['Quick Ratio'] = quick_ratio

        required_metrics_for_ratio['Current Ratio'] = ["Current Assets", "Current Liabilities"]
        required_metrics_for_ratio['Quick Ratio'] = ["Current Assets", "Inventories"]

    elif it_is_a == "cash flow statement":
        cash_flow_from_operations = {}
        cash_flow_from_investing = {}
        cash_flow_from_financing = {}
        current_liabilities = {}
        total_liabilities = {}

        cash_flow_coverage_ratio = {}
        operating_cash_flow_ratio = {}

        print("CASH FLOW DF", df)

        for h in list(df.columns.values)[1:]:
            if 'cash flow from operating activities' == h.lower() or 'cash flow from operations' == h.lower() or 'operating cash flow' == h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        cash_flow_from_operations[df[df.columns[0]][i]] = 0
                    else:
                        cash_flow_from_operations[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'cash flow from investing activities' == h.lower() or 'cash flow from investing' == h.lower() or 'cash flow from investment' == h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        cash_flow_from_investing[df[df.columns[0]][i]] = 0
                    else:
                        cash_flow_from_investing[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'cash flow from financing activities' == h.lower() or 'cash flow from financing' == h.lower():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        cash_flow_from_financing[df[df.columns[0]][i]] = 0
                    else:
                        cash_flow_from_financing[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'current liabilities' == h.lower():
                for i in range(len(df[h].tolist())):
                    if df[h].tolist()[i] == "":
                        continue
                    elif math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        current_liabilities[df[df.columns[0]][i]] = 0
                    else:
                        current_liabilities[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'total liabilities' == h.lower():
                for i in range(len(df[h].tolist())):
                    if df[h].tolist()[i] == "":
                        continue 
                    elif math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        total_liabilities[df[df.columns[0]][i]] = 0
                    else:
                        total_liabilities[df[df.columns[0]][i]] = df[h].tolist()[i]

        # to calc cash flow coverage ratio we need total liabilities
        print("current liabilities", current_liabilities)
        print("total liabilities", total_liabilities)
        if len(current_liabilities) != len(df[df.columns[0]]):
            text.append(dbc.Alert("Enter current liabilities to calculate Operating Cash Flow Ratio.", color="primary"))
        if len(total_liabilities) != len(df[df.columns[0]]):
            text.append(dbc.Alert("Enter total liabilities to calculate Cash Flow Coverage Ratio.", color="primary"))
        
        for y in df.iloc[:, 0].tolist():
            if y in cash_flow_from_operations and y in total_liabilities:
                if total_liabilities[y] == 0:
                    cash_flow_coverage_ratio[y] = 0
                else:
                    cash_flow_coverage_ratio[y] = round(float(cash_flow_from_operations[y]) / float(total_liabilities[y]), 2)
            if y in cash_flow_from_operations and y in current_liabilities:
                if current_liabilities[y] == 0:
                    operating_cash_flow_ratio[y] = 0
                else:
                    operating_cash_flow_ratio[y] = round(float(cash_flow_from_operations[y]) / float(current_liabilities[y]), 2)

        key_metrics['Operating Cash Flow Ratio'] = operating_cash_flow_ratio
        key_metrics['Cash Flow Coverage Ratio'] = cash_flow_coverage_ratio

        required_metrics_for_ratio['Operating Cash Flow Ratio'] = ["Cash Flow from Operating Activities", "Current Liabilities"]
        required_metrics_for_ratio['Cash Flow Coverage Ratio'] = ["Cash Flow from Operating Activities", "Total Liabilities"]

    # pre-define thresholds for the ratios calculated by our app
    thresholds_by_app = {}
    # all key metrics thresholds
    key_metrics_thresholds = {}
    # thresholds for the respective metrics
    for k in key_metrics.keys():
        if k == "Operating Margin":
            key_metrics_thresholds[k] = 20
            thresholds_by_app[k] = 20
        elif k == "Gross Margin":
            key_metrics_thresholds[k] = 50
            thresholds_by_app[k] = 50
        elif k == "Current Ratio":
            key_metrics_thresholds[k] = 1.5
            thresholds_by_app[k] = 1.5
        elif k == "Quick Ratio":
            key_metrics_thresholds[k] = 1
            thresholds_by_app[k] = 1
        elif k == "Cash Flow Coverage Ratio":
            key_metrics_thresholds[k] = 1
            thresholds_by_app[k] = 1
        elif k == "Operating Cash Flow Ratio":
            key_metrics_thresholds[k] = 1
            thresholds_by_app[k] = 1
    print("KEY METRICS THRESHOLDS", key_metrics_thresholds)

    print("threshold data", threshold_data)
    
    # create threshold table for user to edit the thresholds
    threshold_df = pd.DataFrame(key_metrics_thresholds.values(), index=key_metrics_thresholds.keys()).T
    print("threshold df", threshold_df)

    columns = [{"name":i, "id":str(i)} for i in threshold_df.columns]

    if threshold_data is not None:
        new_threshold_df = pd.DataFrame(threshold_data[0].values(), index=threshold_data[0].keys()).T
        print("new_threshold_df", new_threshold_df)
        # if any of the thresholds is not a number, alert user
        if all(str(ele).replace('.', '').isdigit() for ele in threshold_data[0].values()):
            if threshold_data[0] != key_metrics_thresholds:
                key_metrics_thresholds = threshold_data[0]
                threshold_df = new_threshold_df
        else: #if threshold is not a number, dont update
            raise exceptions.PreventUpdate

    # list of the ratios predefined by the app
    app_calculated_ratios = []
    app_calculated_ratios.append(html.P("App calculated ratios for " + it_is_a + " are:"))
    for ratio_name, metrics_needed in required_metrics_for_ratio.items():
        app_calculated_ratios.append(dbc.Badge([html.Span(str(ratio_name), id='tooltip-calc-ratio' + str(ratio_name) + str(all_data), style={"textDecoration": "underline", "cursor": "pointer"}),
                                        dbc.Tooltip("Metrics needed for calculation: " + ", ".join(metrics_needed), target="tooltip-calc-ratio" + str(ratio_name) + str(all_data))], color="white", text_color="dark", className="border me-1")
                                        )
    print(app_calculated_ratios)


    print("line 496 key_metrics", key_metrics)
    # container to output the financial ratios in cards
    container = []
    note = "" # inform user about what the poor ratios mean
    poor_metrics = {} # record the poor ratios

    # Example of key_metrics {'Gross Profit': {2020: 136000, 2021: 120000, 2022: 125000}, 'Gross Margin': {2020: '66.34%', 2021: '68.57%', 2022: '75.76%'}, 'Operating Margin': {2020: '17.8%', 2021: '28.29%', 2022: '27.27%'}}

    # making the cards for each year for each ratio
    for metric_name in key_metrics.keys():
        print("iloc 0", df.iloc[:, 0].tolist())
        metric_container = []
        for i in range(len(key_metrics[metric_name])):
            color = "success"
            inverse = True
            if len(df.iloc[:, 0].tolist()) > 0 and i>0:
                if str(list(key_metrics[metric_name].values())[i]) < str(list(key_metrics[metric_name].values())[i-1]):
                    color = "warning"
                    inverse = False

            if metric_name == "Gross Margin" or metric_name == "Operating Margin":
                if list(key_metrics[metric_name].values())[i] == 0 or float(list(key_metrics[metric_name].values())[i][:-1]) < float(key_metrics_thresholds[metric_name]):
                    color = "danger"
                    inverse = True

                    if metric_name not in poor_metrics:
                        poor_metrics[metric_name] = [str(list(key_metrics[metric_name].keys())[i])]
                    else:
                        poor_metrics[metric_name].append(str(list(key_metrics[metric_name].keys())[i]))
            else:
                if float(list(key_metrics[metric_name].values())[i]) < float(key_metrics_thresholds[metric_name]):
                    color = "danger"
                    inverse = True

                    if metric_name not in poor_metrics:
                        poor_metrics[metric_name] = [str(list(key_metrics[metric_name].keys())[i])]
                    else:
                        poor_metrics[metric_name].append(str(list(key_metrics[metric_name].keys())[i]))

            element = dbc.Card(
                        dbc.CardBody([
                            html.P(str(list(key_metrics[metric_name].keys())[i]) + " " + str(metric_name)),
                            html.H4(str(list(key_metrics[metric_name].values())[i]))
                        ]), className='text-center m-4', color=color, inverse=inverse)
            metric_container.append(dbc.Col(element))
        container.append(dbc.Row(metric_container))

    # description of what the metrics mean when they are in a bad range
    for metric_name in poor_metrics.keys():
        if metric_name == "Operating Margin":
            note += "Return on sales was not managed well in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Gross Margin":
            note += "Company did not make that much money after paying for the direct cost of doing business in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Current Ratio":
            note += "Company's ability to pay short-term obligations was poor in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Quick Ratio":
            note += "Company's ability to convert liquid assets into cash to pay for its short-term financial obligations was poor in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Operating Cash Flow Ratio":
            note += "Company's ability to meet its short-term debt liabilities without considering its dividend policy was poor in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Cash Flow Coverage Ratio":
            note += "Company was in danger of default in " + str(', '.join(poor_metrics[metric_name])) + ". "

    print("TEXT", text)
    print("to_show", container)

    print("threshold df2", threshold_df)
    print("threshold data2", threshold_data)
        
    print("supposed to change", key_metrics_thresholds)

    # table for user to add more ratio calculations
    user_add_ratios_df = pd.DataFrame(columns=["Column 1", "Operator", "Column 2", "Ratio Name"])
    user_add_ratios_columns = [{"name":i, "id":str(i)} for i in user_add_ratios_df.columns]
    print("user_add_ratios_df", user_add_ratios_df)

    user_add_ratios_data = user_add_ratios_df.to_dict('records')

    if user_add_ratios_datatable != None:
        user_add_ratios_data = user_add_ratios_datatable

    print(add_rows_n_clicks)
    # add more rows to add more ratio calculations
    print("line 583 user add ratios", user_add_ratios_datatable)
    print("line 584 user add ratios data", user_add_ratios_data)
    print("line 588 triggered id", ctx.triggered_id)
    if add_rows_n_clicks > 0:
        if 'add-rows-for-ratios' == ctx.triggered_id['type']:
            user_add_ratios_data.append({c['id']: '' for c in user_add_ratios_columns})
    
    print("USER ADD RATIO DATA", user_add_ratios_data)

    print("df line 572", df)
    # get list of names of added ratios by user
    names_of_added_ratios = []
    poor_metrics_added = {} # identify the poor ones
    add_calculations_warning_note = ""

    # all equations in the table is calculated, selected rows will appear in threshold_df and cards
    if user_add_ratios_datatable is not None:
        print("entering for loop", key_metrics)
        print("selected rows 575", selected_rows)
        for i in range(len(user_add_ratios_datatable)):
            if any(ele==None for ele in user_add_ratios_data[i].values()) or any(len(ele)==0 for ele in user_add_ratios_data[i].values()):
                break
            else:
                new_metric_dict = {}
                for v in user_add_ratios_data[i].values(): #check that each cell in the row is not None or not empty string
                    if v != None and v.strip() != "":
                        column_1 = user_add_ratios_data[i]['Column 1']
                        column_2 = user_add_ratios_data[i]['Column 2']
                        print("line 616 key_metrics", key_metrics)
                        for j in range(len(df.iloc[:,0].tolist())): # for each year/quarter
                            print(column_1)
                            print(list(df.columns.values))
                            print(df.iloc[j])
                            if column_1 in list(df.columns.values):
                                column_1_val = float(df.iloc[j][column_1])
                            elif column_1 not in list(df.columns.values) and column_1 in key_metrics.keys():
                                print("line 621 values", list(key_metrics[column_1].values()))
                                column_1_val = float(re.sub("[^0-9.]", "", str(list(key_metrics[column_1].values())[j])))
                            else:
                                add_calculations_warning_note = dbc.Alert("Check if Column name exists or is spelled correctly", color="warning", style={'display': 'inline-block'})
                                break
                            if column_2 in list(df.columns.values):
                                column_2_val = float(df.iloc[j][column_2])
                            elif column_2 not in list(df.columns.values) and column_2 in key_metrics.keys():
                                column_2_val = float(re.sub("[^0-9.]", "", str(list(key_metrics[column_2].values())[j])))
                            else:
                                add_calculations_warning_note = dbc.Alert("Check if Column name exists or is spelled correctly", color="warning", style={'display': 'inline-block'})
                                break

                            year = df.iloc[j,0]
                            print(year)
                            if user_add_ratios_data[i]['Operator'] == "+":
                                new_metric_dict[year] = round(column_1_val + column_2_val, 2)
                            
                            elif user_add_ratios_data[i]['Operator'] == "-":
                                new_metric_dict[year] = round(column_1_val - column_2_val, 2)
                            
                            elif user_add_ratios_data[i]['Operator'] == "*":
                                new_metric_dict[year] = round(column_1_val * column_2_val, 2)
                            
                            elif user_add_ratios_data[i]['Operator'] == "/":
                                new_metric_dict[year] = round(column_1_val / column_2_val, 2)
                            print(new_metric_dict)

                key_metrics[user_add_ratios_data[i]['Ratio Name']] = new_metric_dict
                print("for loop 643", key_metrics)
            if selected_rows is not None:
                for i in selected_rows:
                    if any(ele==None for ele in user_add_ratios_data[i].values()) or any(len(ele)==0 for ele in user_add_ratios_data[i].values()): #or column_1 not in list(df.columns.values) or column_1 not in key_metrics.keys() or column_2 not in list(df.columns.values) or column_2 not in key_metrics.keys():
                        break
                    #append selected ratios to key_metrics_thresholds
                    if user_add_ratios_data[i]['Ratio Name'] not in threshold_df:
                        threshold_df[user_add_ratios_data[i]['Ratio Name']] = 0
                    print("line 623", list(threshold_columns[0].keys()))
                    print("line 624", threshold_columns)
                    if user_add_ratios_data[i]['Ratio Name'] not in [d['name'] for d in threshold_columns]:
                        threshold_columns.append({
                            'name': user_add_ratios_data[i]['Ratio Name'], 'id': user_add_ratios_data[i]['Ratio Name'], 'deletable': True
                        })
                    columns = threshold_columns

                    names_of_added_ratios.append(user_add_ratios_data[i]['Ratio Name'])

        print("key metrics lines 631", key_metrics)
        print("line 632", list(threshold_columns[0].keys()))
        print("columns 633", columns)
        print("columns 634", list(threshold_columns[0]))
    print("line 635", threshold_df)
    print("line 636", key_metrics_thresholds)
    print("line 637", key_metrics)


    # make cards for the selected ratios
    temp = []
    if names_of_added_ratios != []:
        for metric_name in names_of_added_ratios:
            print("line 692", container)
            # metric_container = []
            if metric_name in key_metrics.keys():
                metric_container = []
                for i in range(len(key_metrics[metric_name])): # for each year
                    color = "success"
                    inverse = True
                    if i>0:
                        if str(list(key_metrics[metric_name].values())[i]) < str(list(key_metrics[metric_name].values())[i-1]):
                            color = "warning"
                            inverse = False
                    if float(list(key_metrics[metric_name].values())[i]) < float(threshold_df.iloc[0][metric_name]):
                        color = "danger"
                        inverse = True

                        if metric_name not in poor_metrics_added:
                            poor_metrics_added[metric_name] = [str(list(key_metrics[metric_name].keys())[i])]
                        else:
                            poor_metrics_added[metric_name].append(str(list(key_metrics[metric_name].keys())[i]))

                    element = dbc.Card(
                                dbc.CardBody([
                                    html.P(str(list(key_metrics[metric_name].keys())[i]) + " " + str(metric_name)),
                                    html.H4(str(list(key_metrics[metric_name].values())[i]))
                                ]), className='text-center m-4', color=color, inverse=inverse)
                    metric_container.append(dbc.Col(element))
                    print("line 718", metric_container)
            temp.append(dbc.Row(metric_container))
            
    print("line 723", temp)
    if selected_rows is not None and temp != []:
        for i in range(0, len(selected_rows)):
            container.append(temp[i])

    # place note here to inform the user about the poor metrics below the added ratios
    if note != "":
        container.append(dbc.Alert(note, color="info", style={'display': 'inline-block'}))

    print(threshold_df)
    print(threshold_columns)
    print("line 639 container", container)

    # to get gpt analysis
    gpt_output = ""
    global_keymetrics = {}

    selected_rows_names = [] # the metric names for gpt to analyse
    for d in columns:
        selected_rows_names.append(d['name'])
    
    for metric_name in key_metrics.keys():
        if metric_name in selected_rows_names:
            global_keymetrics[metric_name] = key_metrics[metric_name]
    print("line 746 triggered id", ctx.triggered_id)
    if gpt_n_clicks > 0 and global_keymetrics != {}:
        if 'gpt-button' == ctx.triggered_id['type']:
            response = openai.Completion.create(model="text-davinci-003", 
                                        prompt="write a short report explaining the negatives and possibly any positives based on this statistics(" + str(global_keymetrics) + "). Provide insights and meaning. Do not make any filler sentences. Do not make any suggestions. Do not describe. Do not explain the financial terms.", 
                                        temperature=0.9, 
                                        max_tokens=150)
            gpt_output = dbc.Alert(response["choices"][0]["text"], color="info", style={'display': 'inline-block'})
    # elif gpt_n_clicks > 0 and global_keymetrics == {}:
    #     if 'gpt-button' == ctx.triggered_id['type']:
    #         gpt_output = dbc.Alert("Select the metrics from 'Add Calculations' section to analyse", color="warning", style={'display': 'inline-block'})

    print("--------------------------------------")
    return dbc.Container(container), text, threshold_df.to_dict('records'), columns, app_calculated_ratios, user_add_ratios_data, user_add_ratios_columns, add_calculations_warning_note, gpt_output

