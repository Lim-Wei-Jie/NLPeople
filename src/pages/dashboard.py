import base64
import datetime
import io

import pandas as pd
import plotly.express as px  # (version 4.7.0 or higher)
import plotly.graph_objects as go
import dash
from dash import Dash, dash_table, dcc, html, Input, Output, State, exceptions, MATCH, ALL, no_update, ctx  # pip install dash (version 2.0.0 or higher)

import dash_bootstrap_components as dbc

import math
import re
import numpy as np

import openai
openai.api_key = "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"

dash.register_page(__name__)


layout = html.Div([html.H4('Upload Multiple Saved Excel files to view in Dashboard', id="dashboard-title", style={"cursor": "pointer", 'display': 'inline-block'}),
            dbc.Tooltip("For the dashboard to work: 1) the excel files should be generated by the 'export' button of the 'Extracted Table' in the PDF/Image Tab. 2) The excel files must be CLEANED. To be considered clean, before the excel files were exported, the 'Dashboard' in the PDF/Image Tab should have appeared.", target="dashboard-title", placement="top"),
            dcc.Upload(
                id='upload-data',
                children=html.Div([
                    'Drag and Drop or ',
                    html.A('Select CSV or Excel Files')
                ]),
                style={
                    'width': '90%',
                    'height': '60px',
                    'lineHeight': '60px',
                    'borderWidth': '1px',
                    'borderStyle': 'dashed',
                    'borderRadius': '5px',
                    'textAlign': 'center',
                    'margin': '10px'
                },
                # Allow multiple files to be uploaded
                multiple=True
            ),
            html.Br(),

            html.Div(id='output-data-upload', children=[]),
            ])

# Upload CSV and Excel sheets to the app and create the tables----------------------------------------------------------
@dash.callback(Output('output-data-upload', 'children'),
                Input('upload-data', 'contents'),
                State('upload-data', 'filename'),
                State('upload-data', 'last_modified'),
                State('output-data-upload', 'children'),
                prevent_initial_call=True
)
def update_output(contents, filename, date, children):
    # part of the code snippet is from https://dash.plotly.com/dash-core-components/upload
    if contents is not None:
        for i, (c, n, d) in enumerate(zip(contents, filename, date)):

            content_type, content_string = contents[i].split(',')

            decoded = base64.b64decode(content_string)
            try:
                if 'csv' in filename[i]:
                    # Assume that the user uploaded a CSV file
                    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
                elif 'xls' in filename[i]:
                    # Assume that the user uploaded an excel file
                    df = pd.read_excel(io.BytesIO(decoded))

                # Some cleaning
                # print("BEFORE TRANSPOSE", df)
                df = df.T
                # print("AFTER TRANSPOSE", df)
                new_header = df.iloc[0]
                df = df[1:]
                # print("REMOVE HEADERS", df)
                df.columns = new_header
                # print("WITH NEW HEADER", df)
                print("df.columns", list(df.columns.values))
                # print("df revenue", list(df['Revenue']))

                # df.fillna("0")

                new_columns = []
                for c in df.columns.tolist():
                    new_columns.append(" ".join(c.split("\n")))
                df.set_axis(new_columns, axis=1, inplace=True)

                it_is_a = ''
                all_metrics = list(df.columns.values)
                print("line 94 all_metrics", all_metrics)
                ########
                financial_data_type_list = [ { "revenue": 1, "operating profit": 2, "gross profit": 1, "earnings per share": 2, "owners of the parent": 1, "cost of": 1,
                        "other income": 1, "controlling interest": 1, "net income": 1, "interest expense": 1, "per common share": 2, "per share": 1,
                        "tax expense": 1, "sales": 1 }, # dictionary for words from income statements

                    { "current assets": 2, "fixed assets": 2, "total assets": 2, "inventory": 1, "inventories": 1, "liabilities": 1, "current liabilities": 3,
                        "taxes payable": 1, "long-term debt": 3, "total current liabilities": 3, "equity": 1, "shareholders' equity": 2, "common shares": 2,
                        "common stock": 2 }, # dictionary for words from balance sheets
                    
                    { "cash flow from operating activities": 10, "cash flow from investing activities": 10, "cash flow from financing activities": 10,
                        "cash flows from operating activities": 15, "cash flows from investing activities": 10, "cash flows from financing activities": 10, 
                        "cash flow from": 10, "cash flows from": 10} ] # dictionary for words from cash flow statements
                    
                income_total_weight = 0
                balance_total_weight = 0
                cash_total_weight = 0
                it_is_a = ""

                collect_lowered_fin_terms_from_col = []
                print("line 306 collect_lowered_fin_terms_from_col", collect_lowered_fin_terms_from_col)
                for m in all_metrics:
                    collect_lowered_fin_terms_from_col.append(m.lower())
                print("collect_lowered_fin_terms_from_col: ", collect_lowered_fin_terms_from_col)

                for fin_data_type_dict in financial_data_type_list:
                    if financial_data_type_list[0] == fin_data_type_dict:
                        for income_key in fin_data_type_dict:
                            for collected_term in collect_lowered_fin_terms_from_col:
                                if income_key in collected_term:
                                    income_total_weight += fin_data_type_dict[income_key]
                                    print("added income key: ", income_key)

                    if financial_data_type_list[1] == fin_data_type_dict:
                        for balance_key in fin_data_type_dict:
                            for collected_term in collect_lowered_fin_terms_from_col:
                                if balance_key in collected_term:
                                    balance_total_weight += fin_data_type_dict[balance_key]
                                    print("added balance key: ", balance_key)


                    if financial_data_type_list[2] == fin_data_type_dict:
                        for cash_key in fin_data_type_dict:
                            for collected_term in collect_lowered_fin_terms_from_col:
                                if cash_key in collected_term:
                                    cash_total_weight += fin_data_type_dict[cash_key]
                                    print("added cash key: ", cash_key)

                list_of_weights = [income_total_weight, balance_total_weight, cash_total_weight]

                print("list_of_weights: ", list_of_weights)
                max_value = max(list_of_weights)
                index = list_of_weights.index(max_value)

                if index == 0:
                    it_is_a = "income statement"
                    print("financial data type is income statement")
                elif index == 1:
                    it_is_a = "balance sheet"
                    print("financial data type is balance sheet")
                else:
                    it_is_a = "cash flow statement"
                    print("financial data type is cash flow statement")

                #######
                # if cash flow statement, user needs to add in additional metrics from elsewhere to calculate ratios
                if it_is_a == 'cash flow statement':
                    if "current liabilities" not in collect_lowered_fin_terms_from_col:
                        df['current liabilities'] = np.nan
                    if "total liabilities" not in collect_lowered_fin_terms_from_col:
                        df['total liabilities'] = np.nan

                # Create the tables and empty graphs
                children.append(
                    html.Div([
                        dbc.Row([
                            dbc.Col(
                                dbc.Card([
                                    dbc.CardBody([
                                        html.H4(filename[i]),
                                        dash_table.DataTable(
                                            df.to_dict('records'),
                                            [{'name': i, 'id': i, 'selectable':True} for i in df.columns],
                                            page_size=5,
                                            filter_action='native',
                                            column_selectable='single',
                                            selected_columns=[df.columns[1]], # preselect the 2nd columns
                                            style_table={'overflowX': 'auto'},
                                            id={'type': 'dynamic-table',
                                                'index': i},
                                            editable=True
                                        ),

                                        html.Br(), html.Br(),
                                        html.H4("Thresholds", id={"type": "threshold-heading-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("Threshold values must be numbers!", target={"type": "threshold-heading-tooltip", "index": i}, placement="top"),
                                        html.Br(), 
                                        html.Div(id={
                                                'type': 'app-calculated-ratios',
                                                'index': i
                                            }, style={'display': 'inline-block'}),
                                        html.Br(), html.Br(),
                                        dash_table.DataTable(
                                            page_size=5,
                                            style_table={'overflowX': 'auto'},
                                            id={'type': 'threshold-boxes',
                                                'index': i},
                                            editable=True,
                                        ),

                                        html.Br(), html.Br(),
                                        html.H4("Add Calculations", id={"type": "add-calculations-heading-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("Column 1 and Column 2 accepts EXACT column names or already defined ratio names. Operator accepts +, -, *, /. Ratio Name is text of your choice.", target={"type": "add-calculations-heading-tooltip", "index": i}, placement="top"),
                                        html.Br(),
                                        dash_table.DataTable(
                                            page_size=5,
                                            style_table={'overflowX': 'auto'},
                                            id={'type': 'user-add-ratios',
                                                'index': i},
                                            editable=True,
                                            row_selectable='multi',
                                            row_deletable=True
                                        ),
                                        html.Button('Add Row', 
                                                    id={'type': 'add-rows-for-ratios',
                                                        'index': i},
                                                    n_clicks=0),
                                        html.Br(), html.Br(),
                                        html.Div(id={
                                            'type': 'add-calculations-warning-note',
                                            'index': i
                                        }),

                                        html.Br(), html.Br(),
                                        html.H4("Financial Ratios", id={"type": "financial-ratios-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("Ratios shown are based on the ratios in the 'Thresholds' table", target={"type": "financial-ratios-tooltip", "index": i}, placement="top"),
                                        html.Br(),
                                        html.Div(id={
                                            'type': 'dynamic-text',
                                            'index': i
                                        }, style={'display': 'inline-block'}),
                                        html.P(id={
                                                    'type': 'dynamic-container',
                                                    'index': i
                                            }),

                                        html.Br(), html.Br(),
                                        html.H4("GPT Analysis", id={"type": "gpt-analysis-tooltip", "index": i}, style={"cursor": "pointer", 'display': 'inline-block'}),
                                        dbc.Tooltip("GPT Analysis is based on the ratios in the 'Thresholds' table", target={"type": "gpt-analysis-tooltip", "index": i}, placement="top"),
                                        html.Br(),
                                        html.Button('GPT Analysis', 
                                                    id={'type': 'gpt-button',
                                                        'index': i},
                                                    n_clicks=0),
                                        html.Br(), html.Br(),
                                        html.P(id={
                                                    'type': 'gpt-output',
                                                    'index': i
                                            })
                                    ])
                                ], style={"height":"100%"}), width=6
                            ),
                            dbc.Col(
                                dbc.Card([
                                    dbc.CardBody([
                                        html.P('Type of Graph:'),
                                        dcc.Dropdown(id={'type':'type_of_graph', 'index':i},
                                                    options=['bar', 'line'],
                                                    multi=False,
                                                    value='line',
                                                    style={'width': '40%'}),
                                        
                                        dcc.Graph(
                                            id={
                                                'type': 'dynamic-graph',
                                                'index': i
                                            },
                                            figure={}
                                        ),
                                    ])
                                ], style={"height":"100%"}), width=6
                            )
                        ]),
                        html.Hr()
                    ])
                )

            except Exception as e:
                print(e)
                return html.Div([
                    'There was an error processing this file.'
                ])
        return children
    else:
        return ""


# Build the graphs from the filtered data in the Datatable--------------------------------------------------------------
@dash.callback(Output({'type': 'dynamic-graph', 'index': MATCH}, 'figure'),
                Input({'type': 'dynamic-table', 'index': MATCH}, 'derived_virtual_indices'),
                Input({'type': 'dynamic-table', 'index': MATCH}, 'selected_columns'),
                Input({'type': 'dynamic-table', 'index': MATCH}, 'data'),
                Input({'type': 'type_of_graph', 'index': MATCH}, 'value')
)
def create_graphs(filtered_data, selected_col, all_data, type_of_graph):
    if filtered_data is not None:
        dff = pd.DataFrame(all_data)
        dff = dff[dff.index.isin(filtered_data)].fillna(0)
        dff.replace(r'[^0-9.-]','', regex=True, inplace=True)
        print("line 297:", dff.columns.tolist())
        new_columns = []
        for c in dff.columns.tolist():
            new_columns.append(" ".join(c.split("\n")))
        print("line 305 new columns:", new_columns)
        dff.set_axis(new_columns, axis=1, inplace=True)
        print("line 306:", dff.columns.tolist())
        dff = dff.astype(float)
        print("dff", dff)

        print("line 307 selected col", selected_col[0])
        if selected_col[0] == dff.columns[0]:
            return no_update
        else:
            if type_of_graph == 'line':
                fig = px.line(dff,
                            x = dff.columns[0],
                            y = selected_col[0])
            elif type_of_graph == 'bar':
                fig = px.bar(dff,
                            x = dff.columns[0],
                            y = selected_col[0])
            else:
                raise exceptions.PreventUpdate
            return fig

@dash.callback([Output({'type': 'dynamic-container', 'index': MATCH}, 'children'),
                Output({'type': 'dynamic-text', 'index': MATCH}, 'children'),
                Output({'type': 'threshold-boxes', 'index': MATCH}, 'data'),
                Output({'type': 'threshold-boxes', 'index': MATCH}, 'columns'),
                Output({'type': 'app-calculated-ratios', 'index': MATCH}, 'children'),
                Output({'type': 'user-add-ratios', 'index': MATCH}, 'data'),
                Output({'type': 'user-add-ratios', 'index': MATCH}, 'columns'),
                Output({'type': 'add-calculations-warning-note', 'index': MATCH}, 'children'),
                Output({'type': 'gpt-output', 'index': MATCH}, 'children')],
                Input({'type': 'dynamic-table', 'index': MATCH}, 'data'),
                Input({'type': 'threshold-boxes', 'index': MATCH}, 'data'),
                Input({'type': 'threshold-boxes', 'index': MATCH}, 'columns'),
                State({'type': 'user-add-ratios', 'index': MATCH}, 'data'),
                Input({'type': 'user-add-ratios', 'index': MATCH}, 'columns'),
                Input({'type': 'user-add-ratios', 'index': MATCH}, 'selected_rows'),
                Input({'type': 'add-rows-for-ratios', 'index': MATCH}, 'n_clicks'),
                Input({'type': 'gpt-button', 'index': MATCH}, 'n_clicks'))
def display_metrics(all_data, threshold_data, threshold_columns, user_add_ratios_datatable, user_add_ratios_columns, selected_rows, add_rows_n_clicks, gpt_n_clicks):
    print("ALL DATA", all_data)
    # Income statement, cash flow or balance sheet?
    df = pd.DataFrame(all_data)
    df = df.fillna(0)
    it_is_a = ''
    all_metrics = list(df.columns.values)
    print("line 279", all_metrics)
    text = []
    
    ####################
    financial_data_type_list = [ { "revenue": 1, "operating profit": 2, "operating income": 2,"gross profit": 1, "earnings per share": 2, "owners of the parent": 1, "cost of": 1,
    "other income": 1, "controlling interest": 1, "net income": 1, "interest expense": 1, "per common share": 2, "per share": 1,
    "tax expense": 1, "sales": 1 }, # dictionary for words from income statements

    { "current assets": 2, "total current assets": 2, "fixed assets": 2, "total assets": 2, "inventory": 1, "inventories": 1, "liabilities": 1, "current liabilities": 3, "total liabilities": 3,
    "taxes payable": 1, "long-term debt": 3, "total current liabilities": 3, "equity": 1, "shareholders' equity": 2, "common shares": 2,
    "common stock": 2 }, # dictionary for words from balance sheets
        
    { "cash flow from operating activities": 10, "cash flow from investing activities": 10, "cash flow from financing activities": 10,
    "cash flows from operating activities": 15, "cash flows from investing activities": 10, "cash flows from financing activities": 10, 
    "cash flow from": 10, "cash flows from": 10, "cash and cash equivalents": 5, "operating activities": 5, "financing activities": 5, "investing activities": 5} ] # dictionary for words from cash flow statements
        
    income_total_weight = 0
    balance_total_weight = 0
    cash_total_weight = 0
    it_is_a = ""

    collect_lowered_fin_terms_from_col = []
    print("line 306 collect_lowered_fin_terms_from_col", collect_lowered_fin_terms_from_col)
    for m in all_metrics:
        collect_lowered_fin_terms_from_col.append(m.lower())
    print("collect_lowered_fin_terms_from_col: ", collect_lowered_fin_terms_from_col)

    for fin_data_type_dict in financial_data_type_list:
        if financial_data_type_list[0] == fin_data_type_dict:
            for income_key in fin_data_type_dict:
                for collected_term in collect_lowered_fin_terms_from_col:
                    if income_key in collected_term:
                        income_total_weight += fin_data_type_dict[income_key]
                        print("added income key: ", income_key)

        if financial_data_type_list[1] == fin_data_type_dict:
            for balance_key in fin_data_type_dict:
                for collected_term in collect_lowered_fin_terms_from_col:
                    if balance_key in collected_term:
                        balance_total_weight += fin_data_type_dict[balance_key]
                        print("added balance key: ", balance_key)


        if financial_data_type_list[2] == fin_data_type_dict:
            for cash_key in fin_data_type_dict:
                for collected_term in collect_lowered_fin_terms_from_col:
                    if cash_key in collected_term:
                        cash_total_weight += fin_data_type_dict[cash_key]
                        print("added cash key: ", cash_key)

    list_of_weights = [income_total_weight, balance_total_weight, cash_total_weight]

    print("list_of_weights: ", list_of_weights)
    max_value = max(list_of_weights)
    index = list_of_weights.index(max_value)

    if index == 0:
        it_is_a = "income statement"
        print("financial data type is income statement")
    elif index == 1:
        it_is_a = "balance sheet"
        print("financial data type is balance sheet")
    else:
        it_is_a = "cash flow statement"
        print("financial data type is cash flow statement")

    #######

    print("it is a", it_is_a)

    # this is for user to know the metrics needed to calculate the financial ratios 
    # required metrics will be shown in tooltip
    required_metrics_for_ratio = {}

    # key_metrics is financial ratios 
    key_metrics = {}
    if it_is_a == 'income statement':
        gross_profit = {}
        gross_margin = {}
        operating_income = {}
        operating_margin = {}

        revenue = {}
        cost_of_goods_sold = {}
        operating_expenses = {}

        for h in list(df.columns.values)[1:]: # list of column names except first column
            if 'revenue' in h.lower().strip() or 'net sales' in h.lower().strip(): # if column is about revenue
                for i in range(len(df[h].tolist())): # for each year store the value in a dictionary
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None: # convert 100% to 100 or 14,316 to 14316
                    # if math.isnan(float(df[h].tolist()[i])) or df[h].tolist()[i] is None:
                        revenue[df[df.columns[0]][i]] = 0
                    else:
                        revenue[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'cost of goods sold' in h.lower().strip() or 'cost of revenue' in h.lower().strip() or 'cost of goods' in h.lower().strip() or 'cogs' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        cost_of_goods_sold[df[df.columns[0]][i]] = 0
                    else:
                        cost_of_goods_sold[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'operating expenses' in h.lower().strip() or 'operating expense' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        operating_expenses[df[df.columns[0]][i]] = 0
                    else:
                        operating_expenses[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'gross profit' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        gross_profit[df[df.columns[0]][i]] = 0
                    else:
                        gross_profit[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'operating profit' in h.lower().strip() or 'operating income' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        operating_income[df[df.columns[0]][i]] = 0
                    else:
                        operating_income[df[df.columns[0]][i]] = df[h].tolist()[i]
        
        print("revenue:", revenue)
        print("cost_of_goods_sold", cost_of_goods_sold)

        for y in df.iloc[:, 0].tolist():
            if y in revenue and y in cost_of_goods_sold:
                gross_profit[y] = float(re.sub("[^0-9.-]", "", str(revenue[y]))) - float(re.sub("[^0-9.-]", "", str(cost_of_goods_sold[y])))
            if y in gross_profit and y in revenue:
                if revenue[y] == 0:
                    gross_margin[y] = 0
                else:
                    gross_margin[y] = str(round(float(re.sub("[^0-9.-]", "", str(gross_profit[y]))) / float(re.sub("[^0-9.-]", "", str(revenue[y]))) * 100, 2)) + "%"
            if y in gross_profit and y in operating_expenses:
                operating_income[y] = float(re.sub("[^0-9.-]", "", str(gross_profit[y]))) - float(re.sub("[^0-9.-]", "", str(operating_expenses[y])))
            if y in operating_income and y in revenue:
                if revenue[y] == 0:
                    gross_margin[y] = 0
                else:
                    operating_margin[y] = str(round(float(re.sub("[^0-9.-]", "", str(operating_income[y]))) / float(re.sub("[^0-9.-]", "", str(revenue[y])))*100, 2)) + "%"

        # key_metrics['Gross Profit'] = gross_profit
        key_metrics['Gross Margin'] = gross_margin
        key_metrics['Operating Margin'] = operating_margin

        required_metrics_for_ratio['Gross Margin'] = ["Revenue", "Cost of Goods Sold / Gross Profit"]
        required_metrics_for_ratio['Operating Margin'] = ["Revenue" , "Cost of Goods Sold / Gross Profit", "Operating Expenses / Operating Profit / Operating Income"]

        

    elif it_is_a == 'balance sheet':
        current_ratio = {}
        quick_ratio = {}
        current_assets = {}
        current_liabilities = {}
        inventories = {}
        for h in list(df.columns.values)[1:]:
            if 'current assets' in h.lower().strip() or 'total current assets' in h.lower().strip():
                for i in range(len(df[h].tolist())): 
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        current_assets[df[df.columns[0]][i]] = 0
                    else:
                        current_assets[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'current liabilities' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        current_liabilities[df[df.columns[0]][i]] = 0
                    else:
                        current_liabilities[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'inventories' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        inventories[df[df.columns[0]][i]] = 0
                    else:
                        inventories[df[df.columns[0]][i]] = df[h].tolist()[i]
        
        for y in df.iloc[:, 0].tolist():
            if y in current_assets and y in current_liabilities:
                if current_liabilities[y] == 0:
                    current_ratio[y] = 0
                else: 
                    current_ratio[y] = round(float(re.sub("[^0-9.-]", "", str(current_assets[y]))) / float(re.sub("[^0-9.-]", "", str(current_liabilities[y]))), 2)
            if y in current_assets and y in current_liabilities and y in inventories:
                if current_liabilities[y] == 0:
                    quick_ratio[y] = 0
                else:
                    quick_ratio[y] = round((float(re.sub("[^0-9.-]", "", str(current_assets[y]))) - float(re.sub("[^0-9.-]", "", str(inventories[y])))) / float(re.sub("[^0-9.-]", "", str(current_liabilities[y]))), 2)

        key_metrics['Current Ratio'] = current_ratio
        key_metrics['Quick Ratio'] = quick_ratio

        required_metrics_for_ratio['Current Ratio'] = ["Current Assets", "Current Liabilities"]
        required_metrics_for_ratio['Quick Ratio'] = ["Current Assets", "Inventories"]

    elif it_is_a == "cash flow statement":
        cash_flow_from_operations = {}
        cash_flow_from_investing = {}
        cash_flow_from_financing = {}
        current_liabilities = {}
        total_liabilities = {}

        cash_flow_coverage_ratio = {}
        operating_cash_flow_ratio = {}

        print("CASH FLOW DF", df)

        for h in list(df.columns.values)[1:]:
            if 'cash flow from operating activities' in h.lower().strip() or 'cash flow from operations' in h.lower().strip() or 'operating cash flow' in h.lower().strip() or 'cash flows from operating activities' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        cash_flow_from_operations[df[df.columns[0]][i]] = 0
                    else:
                        cash_flow_from_operations[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'cash flow from investing activities' in h.lower().strip() or 'cash flow from investing' in h.lower().strip() or 'cash flow from investment' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        cash_flow_from_investing[df[df.columns[0]][i]] = 0
                    else:
                        cash_flow_from_investing[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'cash flow from financing activities' in h.lower().strip() or 'cash flow from financing' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        cash_flow_from_financing[df[df.columns[0]][i]] = 0
                    else:
                        cash_flow_from_financing[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'current liabilities' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if df[h].tolist()[i] == "":
                        continue
                    elif math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        current_liabilities[df[df.columns[0]][i]] = 0
                    else:
                        current_liabilities[df[df.columns[0]][i]] = df[h].tolist()[i]
            elif 'total liabilities' in h.lower().strip():
                for i in range(len(df[h].tolist())):
                    if df[h].tolist()[i] == "":
                        continue 
                    elif math.isnan(float(re.sub("[^0-9.-]", "", str(df[h].tolist()[i])))) or df[h].tolist()[i] is None:
                        total_liabilities[df[df.columns[0]][i]] = 0
                    else:
                        total_liabilities[df[df.columns[0]][i]] = df[h].tolist()[i]

        # to calc cash flow coverage ratio we need total liabilities
        print("current liabilities", current_liabilities)
        print("total liabilities", total_liabilities)
        # if len(current_liabilities) != len(df[df.columns[0]]):
        if (df['current liabilities'] == 0).any():
            text.append(dbc.Alert("Enter current liabilities to calculate Operating Cash Flow Ratio.", color="primary"))
        # if len(total_liabilities) != len(df[df.columns[0]]):
        if (df['total liabilities'] == 0).any():
            text.append(dbc.Alert("Enter total liabilities to calculate Cash Flow Coverage Ratio.", color="primary"))
        
        for y in df.iloc[:, 0].tolist():
            if y in cash_flow_from_operations and y in total_liabilities:
                if total_liabilities[y] == 0:
                    cash_flow_coverage_ratio[y] = 0
                else:
                    cash_flow_coverage_ratio[y] = round(float(re.sub("[^0-9.-]", "", str(cash_flow_from_operations[y]))) / float(re.sub("[^0-9.-]", "", str(total_liabilities[y]))), 2)
            if y in cash_flow_from_operations and y in current_liabilities:
                if current_liabilities[y] == 0:
                    operating_cash_flow_ratio[y] = 0
                else:
                    operating_cash_flow_ratio[y] = round(float(re.sub("[^0-9.-]", "", str(cash_flow_from_operations[y]))) / float(re.sub("[^0-9.-]", "", str(current_liabilities[y]))), 2)

        key_metrics['Operating Cash Flow Ratio'] = operating_cash_flow_ratio
        key_metrics['Cash Flow Coverage Ratio'] = cash_flow_coverage_ratio

        required_metrics_for_ratio['Operating Cash Flow Ratio'] = ["Cash Flow from Operating Activities", "Current Liabilities"]
        required_metrics_for_ratio['Cash Flow Coverage Ratio'] = ["Cash Flow from Operating Activities", "Total Liabilities"]

    # pre-define thresholds for the ratios calculated by our app
    thresholds_by_app = {}
    # all key metrics thresholds
    key_metrics_thresholds = {}
    # thresholds for the respective metrics
    for k in key_metrics.keys():
        if k == "Operating Margin":
            key_metrics_thresholds[k] = 20
            thresholds_by_app[k] = 20
        elif k == "Gross Margin":
            key_metrics_thresholds[k] = 50
            thresholds_by_app[k] = 50
        elif k == "Current Ratio":
            key_metrics_thresholds[k] = 1.5
            thresholds_by_app[k] = 1.5
        elif k == "Quick Ratio":
            key_metrics_thresholds[k] = 1
            thresholds_by_app[k] = 1
        elif k == "Cash Flow Coverage Ratio":
            key_metrics_thresholds[k] = 1
            thresholds_by_app[k] = 1
        elif k == "Operating Cash Flow Ratio":
            key_metrics_thresholds[k] = 1
            thresholds_by_app[k] = 1
    print("KEY METRICS THRESHOLDS", key_metrics_thresholds)

    print("threshold data", threshold_data)
    
    # create threshold table for user to edit the thresholds
    threshold_df = pd.DataFrame(key_metrics_thresholds.values(), index=key_metrics_thresholds.keys()).T
    print("threshold df", threshold_df)

    columns = [{"name":i, "id":str(i)} for i in threshold_df.columns]

    if threshold_data is not None:
        new_threshold_df = pd.DataFrame(threshold_data[0].values(), index=threshold_data[0].keys()).T
        print("new_threshold_df", new_threshold_df)
        # if any of the thresholds is not a number, alert user
        if all(str(ele).replace('.', '').isdigit() for ele in threshold_data[0].values()):
            if threshold_data[0] != key_metrics_thresholds:
                key_metrics_thresholds = threshold_data[0]
                threshold_df = new_threshold_df
        else: #if threshold is not a number, dont update
            raise exceptions.PreventUpdate

    # list of the ratios predefined by the app
    app_calculated_ratios = []
    app_calculated_ratios.append(html.P("Here are some financial ratios generated for " + it_is_a + ":"))
    for ratio_name, metrics_needed in required_metrics_for_ratio.items():
        app_calculated_ratios.append(dbc.Badge([html.Span(str(ratio_name), id='tooltip-calc-ratio' + str(ratio_name) + str(all_data), style={"textDecoration": "underline", "cursor": "pointer"}),
                                        dbc.Tooltip("Metrics needed for calculation: " + ", ".join(metrics_needed), target="tooltip-calc-ratio" + str(ratio_name) + str(all_data))], color="white", text_color="dark", className="border me-1")
                                        )
    print(app_calculated_ratios)


    print("line 496 key_metrics", key_metrics)
    # container to output the financial ratios in cards
    container = []
    note = "" # inform user about what the poor ratios mean
    poor_metrics = {} # record the poor ratios

    # Example of key_metrics {'Gross Profit': {2020: 136000, 2021: 120000, 2022: 125000}, 'Gross Margin': {2020: '66.34%', 2021: '68.57%', 2022: '75.76%'}, 'Operating Margin': {2020: '17.8%', 2021: '28.29%', 2022: '27.27%'}}

    # making the cards for each year for each ratio
    for metric_name in key_metrics.keys():
        print("iloc 0", df.iloc[:, 0].tolist())
        metric_container = []
        for i in range(len(key_metrics[metric_name])):
            color = "success"
            inverse = True
            if len(df.iloc[:, 0].tolist()) > 0 and i>0:
                if metric_name == "Gross Margin" or metric_name == "Operating Margin":
                    if float(str(list(key_metrics[metric_name].values())[i])[:-1]) < float(str(list(key_metrics[metric_name].values())[i-1])[:-1]):
                        color = "warning"
                        inverse = False
                
                elif float(str(list(key_metrics[metric_name].values())[i])) < float(str(list(key_metrics[metric_name].values())[i-1])):
                    color = "warning"
                    inverse = False

            if metric_name == "Gross Margin" or metric_name == "Operating Margin":
                if list(key_metrics[metric_name].values())[i] == 0 or float(list(key_metrics[metric_name].values())[i][:-1]) < float(key_metrics_thresholds[metric_name]):
                    color = "danger"
                    inverse = True

                    if metric_name not in poor_metrics:
                        poor_metrics[metric_name] = [str(list(key_metrics[metric_name].keys())[i])]
                    else:
                        poor_metrics[metric_name].append(str(list(key_metrics[metric_name].keys())[i]))
            else:
                if float(list(key_metrics[metric_name].values())[i]) < float(key_metrics_thresholds[metric_name]):
                    color = "danger"
                    inverse = True

                    if metric_name not in poor_metrics:
                        poor_metrics[metric_name] = [str(list(key_metrics[metric_name].keys())[i])]
                    else:
                        poor_metrics[metric_name].append(str(list(key_metrics[metric_name].keys())[i]))

            element = dbc.Card(
                        dbc.CardBody([
                            html.P(str(list(key_metrics[metric_name].keys())[i]) + " " + str(metric_name)),
                            html.H4(str(list(key_metrics[metric_name].values())[i]))
                        ]), className='text-center m-4', color=color, inverse=inverse)
            metric_container.append(dbc.Col(element))
        container.append(dbc.Row(metric_container))

    # description of what the metrics mean when they are in a bad range
    for metric_name in poor_metrics.keys():
        if metric_name == "Operating Margin":
            note += "Return on sales was not managed well in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Gross Margin":
            note += "Company did not make that much money after paying for the direct cost of doing business in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Current Ratio":
            note += "Company's ability to pay short-term obligations was poor in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Quick Ratio":
            note += "Company's ability to convert liquid assets into cash to pay for its short-term financial obligations was poor in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Operating Cash Flow Ratio":
            note += "Company's ability to meet its short-term debt liabilities without considering its dividend policy was poor in " + str(', '.join(poor_metrics[metric_name])) + ". "
        if metric_name == "Cash Flow Coverage Ratio":
            note += "Company was in danger of default in " + str(', '.join(poor_metrics[metric_name])) + ". "

    print("TEXT", text)
    print("to_show", container)

    print("threshold df2", threshold_df)
    print("threshold data2", threshold_data)
        
    print("supposed to change", key_metrics_thresholds)

    # table for user to add more ratio calculations
    user_add_ratios_df = pd.DataFrame(columns=["Column 1", "Operator", "Column 2", "Ratio Name"])
    user_add_ratios_columns = [{"name":i, "id":str(i)} for i in user_add_ratios_df.columns]
    print("user_add_ratios_df", user_add_ratios_df)

    user_add_ratios_data = user_add_ratios_df.to_dict('records')

    if user_add_ratios_datatable != None:
        user_add_ratios_data = user_add_ratios_datatable

    print(add_rows_n_clicks)
    # add more rows to add more ratio calculations
    print("line 583 user add ratios", user_add_ratios_datatable)
    print("line 584 user add ratios data", user_add_ratios_data)
    print("line 588 triggered id", ctx.triggered_id)
    if add_rows_n_clicks > 0:
        if 'add-rows-for-ratios' == ctx.triggered_id['type']:
            user_add_ratios_data.append({c['id']: '' for c in user_add_ratios_columns})
    
    print("USER ADD RATIO DATA", user_add_ratios_data)

    print("df line 572", df)
    # get list of names of added ratios by user
    names_of_added_ratios = []
    poor_metrics_added = {} # identify the poor ones
    add_calculations_warning_note = ""

    # all equations in the table is calculated, selected rows will appear in threshold_df and cards
    if user_add_ratios_datatable is not None:
        print("entering for loop", key_metrics)
        print("selected rows 575", selected_rows)
        for i in range(len(user_add_ratios_datatable)):
            if any(ele==None for ele in user_add_ratios_data[i].values()) or any(len(ele)==0 for ele in user_add_ratios_data[i].values()):
                break
            else:
                new_metric_dict = {}
                for v in user_add_ratios_data[i].values(): #check that each cell in the row is not None or not empty string
                    if v != None and v.strip() != "":
                        column_1 = user_add_ratios_data[i]['Column 1']
                        column_2 = user_add_ratios_data[i]['Column 2']
                        column_1_lower = user_add_ratios_data[i]['Column 1'].lower().strip()
                        column_2_lower = user_add_ratios_data[i]['Column 2'].lower().strip()
                        print("line 616 key_metrics", key_metrics)
                        for j in range(len(df.iloc[:,0].tolist())): # for each year/quarter
                            print(column_1)
                            print(list(df.columns.values))
                            print(df.iloc[j])
                            df_columns_values_lower = [x.lower().strip() for x in list(df.columns.values)]
                            print("line 798", df_columns_values_lower)
                            if column_1_lower in df_columns_values_lower:
                                idx = df_columns_values_lower.index(column_1_lower)
                                column_1 = list(df.columns.values)[idx]
                                column_1_val = float(re.sub("[^0-9.-]", "", str(df.iloc[j][column_1])))
                            elif column_1_lower not in df_columns_values_lower and column_1 in key_metrics.keys():
                                print("line 621 values", list(key_metrics[column_1].values()))
                                idx = df_columns_values_lower.index(column_1_lower)
                                column_1 = list(df.columns.values)[idx]
                                column_1_val = float(re.sub("[^0-9.-]", "", str(list(key_metrics[column_1].values())[j])))
                            else:
                                add_calculations_warning_note = dbc.Alert("Check if Column name exists or is spelled correctly", color="warning", style={'display': 'inline-block'})
                                break
                            if column_2_lower in df_columns_values_lower:
                                idx = df_columns_values_lower.index(column_2_lower)
                                column_2 = list(df.columns.values)[idx]
                                column_2_val = float(re.sub("[^0-9.-]", "", str(df.iloc[j][column_2])))
                            elif column_2_lower not in df_columns_values_lower and column_2 in key_metrics.keys():
                                idx = df_columns_values_lower.index(column_2_lower)
                                column_2 = list(df.columns.values)[idx]
                                column_2_val = float(re.sub("[^0-9.-]", "", str(list(key_metrics[column_2].values())[j])))
                            else:
                                add_calculations_warning_note = dbc.Alert("Check if Column name exists or is spelled correctly", color="warning", style={'display': 'inline-block'})
                                break

                            year = df.iloc[j,0]
                            print(year)
                            if user_add_ratios_data[i]['Operator'] == "+":
                                new_metric_dict[year] = round(column_1_val + column_2_val, 2)
                            
                            elif user_add_ratios_data[i]['Operator'] == "-":
                                new_metric_dict[year] = round(column_1_val - column_2_val, 2)
                            
                            elif user_add_ratios_data[i]['Operator'] == "*":
                                new_metric_dict[year] = round(column_1_val * column_2_val, 2)
                            
                            elif user_add_ratios_data[i]['Operator'] == "/":
                                new_metric_dict[year] = round(column_1_val / column_2_val, 2)
                            print(new_metric_dict)

                key_metrics[user_add_ratios_data[i]['Ratio Name']] = new_metric_dict
                print("for loop 643", key_metrics)
            if selected_rows is not None:
                for i in selected_rows:
                    if any(ele==None for ele in user_add_ratios_data[i].values()) or any(len(ele)==0 for ele in user_add_ratios_data[i].values()): #or column_1 not in list(df.columns.values) or column_1 not in key_metrics.keys() or column_2 not in list(df.columns.values) or column_2 not in key_metrics.keys():
                        break
                    #append selected ratios to key_metrics_thresholds
                    if user_add_ratios_data[i]['Ratio Name'] not in threshold_df:
                        threshold_df[user_add_ratios_data[i]['Ratio Name']] = 0
                    print("line 623", list(threshold_columns[0].keys()))
                    print("line 624", threshold_columns)
                    if user_add_ratios_data[i]['Ratio Name'] not in [d['name'] for d in threshold_columns]:
                        threshold_columns.append({
                            'name': user_add_ratios_data[i]['Ratio Name'], 'id': user_add_ratios_data[i]['Ratio Name'], 'deletable': True
                        })
                    columns = threshold_columns

                    names_of_added_ratios.append(user_add_ratios_data[i]['Ratio Name'])

        print("key metrics lines 631", key_metrics)
        print("line 632", list(threshold_columns[0].keys()))
        print("columns 633", columns)
        print("columns 634", list(threshold_columns[0]))
    print("line 635", threshold_df)
    print("line 636", key_metrics_thresholds)
    print("line 637", key_metrics)


    # make cards for the selected ratios
    temp = []
    if names_of_added_ratios != []:
        for metric_name in names_of_added_ratios:
            print("line 692", container)
            # metric_container = []
            if metric_name in key_metrics.keys():
                metric_container = []
                for i in range(len(key_metrics[metric_name])): # for each year
                    color = "success"
                    inverse = True
                    if i>0:
                        if float(str(list(key_metrics[metric_name].values())[i])) < float(str(list(key_metrics[metric_name].values())[i-1])):
                            color = "warning"
                            inverse = False
                    if float(list(key_metrics[metric_name].values())[i]) < float(threshold_df.iloc[0][metric_name]):
                        color = "danger"
                        inverse = True

                        if metric_name not in poor_metrics_added:
                            poor_metrics_added[metric_name] = [str(list(key_metrics[metric_name].keys())[i])]
                        else:
                            poor_metrics_added[metric_name].append(str(list(key_metrics[metric_name].keys())[i]))

                    element = dbc.Card(
                                dbc.CardBody([
                                    html.P(str(list(key_metrics[metric_name].keys())[i]) + " " + str(metric_name)),
                                    html.H4(str(list(key_metrics[metric_name].values())[i]))
                                ]), className='text-center m-4', color=color, inverse=inverse)
                    metric_container.append(dbc.Col(element))
                    print("line 718", metric_container)
            temp.append(dbc.Row(metric_container))
            
    print("line 723", temp)
    if selected_rows is not None and temp != []:
        for i in range(0, len(selected_rows)):
            container.append(temp[i])

    # place note here to inform the user about the poor metrics below the added ratios
    if note != "":
        container.append(dbc.Alert(note, color="info", style={'display': 'inline-block'}))

    print(threshold_df)
    print(threshold_columns)
    print("line 639 container", container)

    # to get gpt analysis
    gpt_output = ""
    global_keymetrics = {}

    selected_rows_names = [] # the metric names for gpt to analyse
    for d in columns:
        selected_rows_names.append(d['name'])
    
    for metric_name in key_metrics.keys():
        if metric_name in selected_rows_names:
            global_keymetrics[metric_name] = key_metrics[metric_name]
    print("line 746 triggered id", ctx.triggered_id)
    print("line 774 global_keymetrics", str(global_keymetrics))

    # remove empty dictionary for ratio in global_keymetrics
    # eg {'Gross Margin': {}, 'Operating Margin': {1: '15.05%', 2: '11.76%', 3: '9.25%', 4: '10.51%', 5: '7.8%', 6: '8.36%', 7: '8.06%', 8: '8.8%'}, '2xRevenue': {1: 264.4, 2: 546.0, 3: 1079.2, 4: 291.2, 5: 590.0, 6: 550.0, 7: 1240.0, 8: 1250.0}}
    # remove gross margin ratio since its empty
    metrics_to_remove = []
    for k,v in global_keymetrics.items():
        if v == {}:
            metrics_to_remove.append(k)
    for m in metrics_to_remove:
        del global_keymetrics[m]
    print("line 780 global_keymetrics", str(global_keymetrics))
    
    # thresholds to base on for gpt analysis
    gpt_analysis_thresholds = {}
    for k,v in key_metrics_thresholds.items():
        if k in global_keymetrics.keys():
            gpt_analysis_thresholds[k] = v
    print("line 787 gpt_analysis_thresholds", str(gpt_analysis_thresholds))

    if gpt_n_clicks > 0 and global_keymetrics != {}:
        if 'gpt-button' == ctx.triggered_id['type']:
            response = openai.Completion.create(model="text-davinci-003", 
                                        prompt="Provide a concise report that is only one paragraph long and discusses the positives and negatives of a company with the following financial statistics:(" + str(global_keymetrics) + "). The financial statistics should be higher than their respective thresholds:(" + str(gpt_analysis_thresholds) + ") to be considered good perfomance. Your report should contain suggestions for improving performance and provide insights, but avoid explaining the financial terms and fillers. Do not describe the data. Do not refer to yourself as an individual.", 
                                        temperature=0.9, 
                                        max_tokens=150)
            gpt_output = dbc.Alert(response["choices"][0]["text"], color="info", style={'display': 'inline-block'})
    # elif gpt_n_clicks > 0 and global_keymetrics == {}:
    #     if 'gpt-button' == ctx.triggered_id['type']:
    #         gpt_output = dbc.Alert("Select the metrics from 'Add Calculations' section to analyse", color="warning", style={'display': 'inline-block'})

    print("--------------------------------------")
    return dbc.Container(container), text, threshold_df.to_dict('records'), columns, app_calculated_ratios, user_add_ratios_data, user_add_ratios_columns, add_calculations_warning_note, gpt_output

